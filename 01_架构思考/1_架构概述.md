# <a id="a_top">1、架构概述</a> [分布式架构思考]() [2、RPC服务]()

### <a id="a_catalogue">目录</a>：
1. <a href="#a_01">一、分布式架构</a>
2. <a href="#a_11">为什么需要分布式架构</a>
3. <a href="#a_12">理解单体架构</a>
4. <a href="#a_13">理解分布式架构</a>
5. <a href="#a_14">分布式架构的特征</a>
6. <a href="#a_15">理论/思想</a>
7. <a href="#a_16">关键词</a>
8. <a href="#a_02">二、微服务架构</a>
9. <a href="#a_21">什么是微服务架构</a>
10. <a href="#a_22">微服务的出现与发展</a>
11. <a href="#a_23">微服务的特征</a>
12. <a href="#a_24">如何具体实践微服务</a>
13. <a href="#a_25">常见的微服务设计模式和应用</a>
14. <a href="#a_26">微服务的优点和缺点</a>
15. <a href="#a_27">相关扩展</a>
99. <a href="#a_down">down</a>

|作者|Mutistic|
|---|---|
|邮箱|mutistic@qq.com|

---
## <a id="a_01">一、分布式架构：</a> <a href="#a_catalogue">目录</a> <a href="#a_02">二、微服务架构</a>
### <a id="a_11">1.1、为什么需要分布式架构：</a> <a href="#a_12">next</a>
```
  谈到分布式架构，首先要明白的为什么要从单体架构改造成分布式架构，那么单体架构的优劣是什么，而分布式架构在此中解决了什么问题，而又引发了什么问题？
```

---
### <a id="a_12">1.2、理解单体架构：</a> <a href="#a_11">last</a> <a href="#a_13">next</a>
1、什么是单体架构：
```
  一般而言，将一整套系统集中部署在单服务器上，对外提供服务，可以认为是单体架构。
  
  在最初的系统设计中，是没有对项目进行模块化、微服务化、分布式部署，各种代码一般都集中在一个工程项目中，工程项目会变得越发庞大
```
2、单体架构的优点：
```
  显著的优点是成本低，没有分布式架构中的一些弊端，技术体系相对而言较低
```
3、单体架构的缺点：
```
  系统容易出现性能瓶颈，项目耦合度过高导致维护成本比较高，系统的可用性相对而言不高，对横向扩展支持比较差（扩展性差），不能灵活进行分布式部署。
```

---
### <a id="a_13">1.3、理解分布式架构：</a> <a href="#a_12">last</a> <a href="#a_14">next</a>
1、什么是分布式架构：
```
  广泛的定义：分布式架构是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。
  
  所谓的节点是指一台服务器，这些节点通过网络相互连通，然后软件部署在这些节点上，进行协同工作。
```

2、分布式架构的目的：
```
  什么情景下引入分布式架构：
    当单体架构的处理能力无法满足日益增长的业务、计算、存储任等需求，单服务器的纵向扩展比如硬件的提升（加内存、硬盘容量、固态硬盘、高性能CPU） 成本高昂，
应用系统无法通过优化解决这些问题时，我们才考虑分布式架构，分布式架构与单体架构解决的问题是一致的，而分布式架构的只是在技术层面优化单体架构的缺点。

  分布式架构的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。
  
  其目的是利用更多的机器，处理更多的数据
```

3、分布式架构的优点：
```
  提升系统的性能和并发、提升系统的可用性、使得横向扩展变得简单、降低系统的耦合度、提高开发效率、可以进行分布式部署、独立部署
```

4、分布式架构的缺点：
```
  分布式架构会带来更多的技术栈、学习成本高、不可靠的网络问题、异构的机器与网络、普遍的节点故障、测试成本提高
```

5、比较分布式架构和单体架构：

| |传统单体架构|分布式服务化框架|
|---|---|---|
|新功能开发|需要开发|容易开发和实现|
|部署|不经常部署且容易部署|经常发布，部署复杂|
|隔离性|故障影响范围大|故障影响范围小|
|架构设计|难度小|难度级数增加|
|系统性能|响应时间快，吞吐量小|响应时间慢，吞吐量大|
|系统运维|运维简单|运维复杂|
|上手掌握|应用逻辑学习曲线大|架构逻辑学习曲线大|
|技术|技术单一且封闭|技术多样性且开放|
|测试和纠错|简单|复杂|
|系统扩展性|扩展性差|扩展性好|
|系统管理|重点在开发成本|重点在服务治理和|

6、分布式架构引发的问题：
```
  服务节点管理、负载均衡、双主问题（脑裂问题）、数据均衡分布、数据一致性、网络问题、session共享、分布式事务等问题
```

---
### <a id="a_14">1.4、分布式架构的特征：</a> <a href="#a_13">last</a> <a href="#a_15">next</a>
1、可扩展性：
```
  可扩展性指当架构的任务增加的时候，通过增加资源来应对任务增长的能力。
  扩展性的目标是使得系统中的节点都在一个较为稳定的负载下工作，这就是负载均衡，当然，
在动态增加节点的时候，需要进行任务（可能是计算或数据存储）的迁移，以达到动态均衡
```

2、高性能：
```
  分布式系统的理想目标是任务与节点按一定的比例线性增长
```

3、高可用：
```
  可用性（Availability）是架构不间断对外提供服务的能力，可用性是一个度的问题，最高目标就是7 * 24，即永远在线，
但事实上做不到的，一般是用几个9来衡量系统的可用性。
  
  4个九特指一年中系统的可用性为99.99%
```

4：[一致性](https://www.cnblogs.com/biterror/p/6909624.html):
```
  从系统角度的一致性：强一致性、弱一致性、最终一致性
  从用户角度的一致性：单调读一致性，单调写一致性，读后写一致性，写后读一致性
```

---
### <a id="a_15">1.5、理论/思想：</a> <a href="#a_14">last</a> <a href="#a_16">next</a>
1、[摩尔定律](https://baike.baidu.com/item/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B)：
```
  价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，
将每隔18-24个月翻一倍以上。
  这一定律揭示了信息技术进步的速度
```

2、[CAP定理](https://baike.baidu.com/item/CAP%E5%AE%9A%E7%90%86)：
```
  CAP定理（CAP theorem），又称CAP原则和作布鲁尔定理（Brewer's theorem）：

  1、一致性（C：Consistency）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。即数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。
同时，一致性也是指事务的基本特征或特性相同，其他特性或特征相类似。

  2、可用性（A：Availability）：在集群（由多个独立的计算机通过高速的通信网络连接起来的,具有单一系统映象的高性能计算机系统）中一部分节点故障后，
集群整体是否还能响应客户端的读写请求。（可用性不仅包括读，还有写）
  
  3、分区容忍性（P：Partition tolerance）：集群中的某些节点在无法联系后，集群整体是否还能继续进行服务。
系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择
```

3、[ACID](https://baike.baidu.com/item/acid/10738)：
```
   ACID，指数据库事务正确执行的四个基本要素的缩写，包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
   一个支持事务（Transaction）的数据库，必须要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性
   
   1、原子性（A：Atomicity）：
   整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。
   事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样
   
   2、一致性（C：Consistency）：
   一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少
   也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)
   
   3、隔离性（I：Isolation）：
   隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。
   这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据
   
   4、持久性（D：Durability）：
   在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。
   由于一项操作通常会包含许多子操作，而这些子操作可能会因为硬件的损坏或其他因素产生问题，要正确实现ACID并不容易。
   ACID建议数据库将所有需要更新以及修改的资料一次操作完毕，但实际上并不可行。
  
   目前主要有两种方式实现ACID：第一种是WAL（Write ahead logging，日志式的方式），现代数据库均基于这种方式。第二种是Shadow paging（影子分页技术）
   4.1、WAL 的中心思想是对数据文件的修改（它们是表和索引的载体）必须是只能发生在这些修改已经记录了日志之后，
   也就是说，在日志记录冲刷到永久存储器之后．如果我们遵循这个过程，那么我们就不需要在每次事务提交的时候 都把数据页冲刷到磁盘，
   因为我们知道在出现崩溃的情况下，我们可以用日志来恢复数据库：
   任何尚未附加到数据页的记录 都将先从日志记录中重做（这叫向前滚动恢复，也叫做 REDO） 
   然后那些未提交的事务做的修改将被从数据页中删除 （这叫向后滚动恢复 - UNDO）
  
   4.2、相对于WAL（write ahead logging）技术，shadow paging技术实现起来比较简单，消除了写日志记录的开销恢复的速度也快(不需要redo和undo)。
   shadow paging的缺点就是事务提交时要输出多个块，这使得提交的开销很大，而且以块为单位，很难应用到允许多个事务并发执行的情况——这是它致命的缺点。
```

4、BASE思想：
```
  BASE思想主要强调基本的可用性，如果你需要高可用性，也就是纯粹的高性能，那么就要以一致性或容错性为牺牲
  
  BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性： 
  1、基本可用(BA：Basically Available）：支持分区失败(如，sharding碎片划分数据库) 
  2、软状态/柔性事务（S：Soft state）：状态可以有一段时间不同步，异步。 Soft state 可以理解为无连接的, 而 Hard state 是面向连接的 
  3、最终一致（E：Eventually consistent）：最终数据是一致的就可以了，而不是时时一致。最终一致性，也是是 ACID 的最终目的
  
  BASE思想的主要实现有：
  1.按功能划分数据库
  2.sharding碎片
```

---
### <a id="a_16">1.6、关键词：</a> <a href="#a_15">last</a> <a href="#a_21">next</a>
```
  节点，时间，一致性，CAP，ACID，BASE，P2P，机器伸缩，网络变更，负载均衡，限流，鉴权，服务发现，服务编排，降级，熔断，
  幂等，分库分表，分片分区，自动运维，容错处理，全栈监控，故障恢复，性能调优
```


---
## <a id="a_02">二、微服务架构：</a> <a href="#a_01">一、分布式架构</a> <a href="#a_03">三、</a>
### <a id="a_21">2.1、什么是微服务架构</a> <a href="#a_16">next</a> <a href="#a_22">next</a>
```
  微服务架构（Microservice Architecture）：是一种架构概念，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。
你可以将其看作是在架构层次而非获取服务的类上应用很多SOLID原则（面向对象设计原则）。
微服务架构是个很有趣的概念，它的主要作用是将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。

  概念：把一个大型的单个应用程序和服务拆分为数个甚至数十个的支持微服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。

  定义：围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代。在分散的组件中使用云架构和平台式部署、管理和服务功能，使产品交付变得更加简单。

  本质：用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题
```

---
### <a id="a_22">2.2、微服务的出现与发展</a> <a href="#a_21">last</a> <a href="#a_23">next</a>
```
  微服务（Microservice）这个概念是2012年出现的，作为加快Web和移动应用程序开发进程的一种方法，2014年开始受到各方的关注，而2015年，可以说是微服务的元年；
越来越多的论坛、社区、blog以及互联网行业巨头开始对微服务进行讨论、实践，可以说这样更近一步推动了微服务的发展和创新。而微服务的流行，Martin Fowler功不可没，他特别擅长抽象归纳和制造概念。特别是微服务这种新生的名词，都有一个特点：一解释就懂，一问就不知，一讨论就打架

  Martin Fowler是国际著名的OO专家，敏捷开发方法的创始人之一，现为ThoughtWorks公司的首席科学家。
在面向对象分析设计、UML、模式、软件开发方法学、XP、重构等方面，都是世界顶级的专家，现为Thought Works公司的首席科学家。
Thought Works是一家从事企业应用开发和——集成的公司。
早在20世纪80年代，Fowler就是使用对象技术构建多层企业应用的倡导者，他著有几本经典书籍： 《企业应用架构模式》、《UML精粹》和《重构》等
```

---
### <a id="a_23">2.3、微服务的特征</a> <a href="#a_22">last</a> <a href="#a_24">next</a>
1、官方的定义：
```
  1、一些列的独立的服务共同组成系统
  2、单独部署，跑在自己的进程中
  3、每个服务为独立的业务开发
  4、分布式管理
  5、非常强调隔离性
```
2、大概的标准：
```
  1、分布式服务组成的系统
  2、按照业务，而不是技术来划分组织
  3、做有生命的产品而不是项目
  4、强服务个体和弱通信（ Smart endpoints and dumb pipes ）
  5、自动化运维（ DevOps ）
  6、高度容错性
  7、快速演化和迭代
```

---
### <a id="a_24">2.4、如何具体实践微服务</a> <a href="#a_23">last</a> <a href="#a_25">next</a>
1、要实际的应用微服务，需要解决一下四点问题：
```
  1、客户端如何访问这些服务
  2、每个服务之间如何通信
  3、如此多的服务，如何实现？
  4、服务挂了，如何解决？（备份方案，应急处理机制）
```
2、客户端如何访问这些服务：
```
  原来的单体(Monolithic)方式开发，所有的服务都是本地的，UI可以直接调用，现在按功能拆分成独立的服务，跑在独立的一般都在独立的虚拟机上的 Java进程了。
客户端UI如何访问他的？后台有N个服务，前台就需要记住管理N个服务，一个服务下线/更新/升级，前台就要重新部署，这明显不服务我们 拆分的理念，特别当前台是移动应用的时候，通常业务变化的节奏更快。

  另外，N个小服务的调用也是一个不小的网络开销。还有一般微服务在系统内部，通常是无状态的，用户登录信息和权限管理最好有一个统一的地方维护管理（OAuth）。

  所以，一般在后台N个服务和UI之间一般会一个代理或者叫API Gateway(API网关)，他的作用包括：
  1、提供统一服务入口，让微服务对前台透明
  2、聚合后台的服务，节省流量，提升性能
  3、提供安全，过滤，流控等API管理功能
  
  其实这个API Gateway可以有很多广义的实现办法，可以是一个软硬一体的盒子，也可以是一个简单的MVC框架，甚至是一个Node.js的服务端。
他们最重要的作 用是为前台（通常是移动应用）提供后台服务的聚合，提供一个统一的服务出口，解除他们之间的耦合。

  不过API Gateway也有可能成为单点故障点或者性能的瓶颈
```
![2.4.2_客户端访问服务方式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.4.2_%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E6%96%B9%E5%BC%8F.png)

3、每个服务之间如何通信：  
[RESTful 架构详解](https://www.runoob.com/w3cnote/restful-architecture.html)
```
  所有的微服务都是独立的Java进程跑在独立的虚拟机上，所以服务间的通信就是IPC（inter process communication），已经有很多成熟的方案。
现在基本最通用的有两种方式：
  1、同步调用：REST风格（JAX-RS，Spring Boot）、RPC风格（Thrift, Dubbo）
  2、异步消息调用：RocketMQ、RabbitMQ、Kafka、ActiveMQ
```
3.2、同步和异步的区别：
```
  1、同步：
  一般同步调用比较简单，一致性强，但是容易出调用问题，性能体验上也会差些，特别是调用层次多的时候。RESTful和RPC的比较也是一个很有意思的话题。
  一般REST基于HTTP，更容易实现，更容易被接受，服务端实现技术也更灵活些，各个语言都能支持，同时能跨客户端，对客户端没有特殊的要求，只要封装了HTTP的
SDK就能调用，所以相对使用的广一些。
  RPC也有自己的优点，传输协议更高效，安全更可控，特别在一个公司内部，如果有统一个的开发规范和统一的服务框架时，他的开发效率优势更明显些。
就看各自的技术积累实际条件和选择了。

  2、异步消息：
  异步消息的方式在分布式系统中有特别广泛的应用，他既能减低调用服务之间的耦合，又能成为调用之间的缓冲，确保消息积压不会冲垮被调用方，
同时能保证调用方的服务体验，继续干自己该干的活，不至于被后台性能拖慢。
  不过需要付出的代价是一致性的减弱，需要接受数据最终一致性；
  还有就是后台服务一般要 实现幂等性，因为消息发送出于性能的考虑一般会有重复（保证消息的被收到且仅收到一次对性能是很大的考验）；
  最后就是必须引入一个独立的broker，如果公司内部没有技术积累，对broker分布式管理也是一个很大的挑战
```
![2.4.3_服务间的通信方式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.4.3_%E6%9C%8D%E5%8A%A1%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.png)

4、如此多的服务，如何实现？
```
  在微服务架构中，一般每一个服务都是有多个拷贝，来做负载均衡。一个服务随时可能下线，也可能应对临时访问压力增加新的服务节点。

  服务之间如何相互感知？服务如何管理？这就是服务发现的问题了。一般有两类做法，也各有优缺点。
  基本都是通过zookeeper等类似技术做服务注册信息的分布式管理。
  1、当服务上线时，服务提供者将自己的服务信息注册到ZK（或类似框架），并通过心跳维持长链接，实时更新链接信息。
  2、服务调用者通过ZK寻址，根据可定制算法，找到一个服务，还可以将服务信息缓存在本地以提高性能。
  3、当服务下线时，ZK会发通知给服务客户端。
  
  客户端做：优点是架构简单，扩展灵活，只对服务注册器依赖。缺点是客户端要维护所有调用服务的地址，有技术难度，一般大公司都有成熟的内部框架支持，比如Dubbo。
  服务端做：优点是简单，所有服务对于前台调用方透明，一般在小公司在云服务上部署的应用采用的比较多
```
![2.4.4_服务的管理方式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.4.4_%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F.png)

5、服务挂了，如何解决：
```
  前面提到，Monolithic方式开发一个很大的风险是，把所有鸡蛋放在一个篮子里，一荣俱荣，一损俱损。
而分布式最大的特性就是网络是不可靠的。通过微服务拆分能降低这个风险，

  不过如果没有特别的保障，结局肯定是噩梦。所以当我们的系统是由一系列的服务调用链组成的时候，我们必须确保任一环节出问题都不至于影响整体链路。
  相应的手段有很多：重试机制、限流、熔断机制、负载均衡、降级（本地缓存）
  这些方法基本都很明确通用，比如Netflix的Hystrix
```
![2.4.5_服务容错方式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.4.5_%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E6%96%B9%E5%BC%8F.png)

---
### <a id="a_25">2.5、常见的微服务设计模式和应用</a> <a href="#a_24">last</a> <a href="#a_26">next</a>
1、总结微服务架构需要考虑的问题，包括：API Gateway、服务间调用、服务发现、服务容错、服务部署、数据调用  
![2.5.1_微服务架构需要考虑的问题](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.5.1_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98.png)

2、六种常见的微服务架构设计模式：  
2.1、聚合器微服务设计模式：
![2.5.2.1_聚合器微服务设计模式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.5.2.1_%E8%81%9A%E5%90%88%E5%99%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png)
```
  这是一种最常见也最简单的设计模式，聚合器调用多个服务实现应用程序所需的功能。它可以是一个简单的Web页面，将检索到的数据进行处理展示。
它也可以是一个更高层次的组合微服务，对检索到的数据增加业务逻辑后进一步

  发布成一个新的微服务，这符合DRY原则。另外，每个服务都有自己的缓存和数据库。
如果聚合器是一个组合服务，那么它也有自己的缓存和数据库。聚合器可以沿X轴和Z轴独立扩展
```
2.2、代理微服务设计模式：
![2.5.2.2_代理微服务设计模式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.5.2.2_%E4%BB%A3%E7%90%86%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png)
```
  这是聚合模式的一个变种，在这种情况下，客户端并不聚合数据，但会根据业务需求的差别调用不同的微服务。代理可以仅仅委派请求，也可以进行数据转换工作
```
2.3、链式微服务设计模式：
![2.5.2.3_链式微服务设计模式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.5.2.3_%E9%93%BE%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png)
```
  这种模式在接收到请求后会产生一个经过合并的响应，在这种情况下，服务A接收到请求后会与服务B进行通信，类似地，服务B会同服务C进行通信。
所有服务都使用同步消息传递。在整个链式调用完成之前，客户端会一直阻塞。因此，服务调用链不宜过长，以免客户端长时间等待
```
2.4、分支微服务设计模式：
![2.5.2.4_分支微服务设计模式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.5.2.4_%E5%88%86%E6%94%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png)
```
  这种模式是聚合器模式的扩展，允许同时调用两个微服务链
```
2.5、数据共享微服务设计模式：
![2.5.2.5_数据共享微服务设计模式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.5.2.5_%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png)
```
  自治是微服务的设计原则之一，就是说微服务是全栈式服务。但在重构现有的“单体应用（monolithic application）”时，SQL数据库反规范化可能会导致数据重复和不一致。
因此，在单体应用到微服务架构的过渡阶段，可以使用这种设计模式，在这种情况下，部分微服务可能会共享缓存和数据库存储。
不过，这只有在两个服务之间存在强耦合关系时才可以。对于基于微服务的新建应用程序而言，这是一种反模式
```
2.6、异步消息传递微服务设计模式：
![2.5.2.6_异步消息传递微服务设计模式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.5.2.6_%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png)
```
  虽然REST设计模式非常流行，但它是同步的，会造成阻塞。因此部分基于微服务的架构可能会选择使用消息队列代替REST请求/响应。
```

---
### <a id="a_26">2.6、微服务的优点和缺点</a> <a href="#a_25">last</a> <a href="#a_27">next</a>
1、微服务的优点：
```
  关键点：复杂度可控，独立按需扩展，技术选型灵活，容错，可用性高
  1、它解决了复杂性的问题。它会将一种怪异的整体应用程序分解成一组服务。虽然功能总量 不变，但应用程序已分解为可管理的块或服务。
每个服务都以RPC或消息驱动的API的形式定义了一个明确的边界；Microservice架构模式实现了一个模块化水平。
  
  2、这种架构使每个服务都能够由专注于该服务的团队独立开发。开发人员可以自由选择任何有用的技术，只要该服务符合API合同。
当然，大多数组织都希望避免完全无政府状态并限制技术选择。然而，这种自由意味着开发人员不再有义务使用在新项目开始时存在的可能过时的技术。
在编写新服务时，他们可以选择使用当前的技术。此外，由于服务相对较小，因此使用当前技术重写旧服务变得可行。
  
  3、Microservice架构模式使每个微服务都能独立部署。开发人员不需要协调部署本地服务的变更。这些变化可以在测试后尽快部署。
例如，UI团队可以执行A | B测试，并快速迭代UI更改。Microservice架构模式使连续部署成为可能。
  
  4、Microservice架构模式使每个服务都可以独立调整。可以仅部署满足其容量和可用性限制的每个服务的实例数。此外，可以使用最符合服务资源要求的硬件。
```
 

2、微服务的缺点
```
  关键点（挑战）：多服务运维难度，系统部署依赖，服务间通信成本，数据一致性，系统集成测试，重复工作，性能监控等

  1、一个缺点是名称本身。术语Microservice过度强调服务规模。但重要的是要记住，这是一种手段，而不是主要目标。
微服务的目标是充分分解应用程序，以便于敏捷应用程序开发和部署。

  2、微服务器的另一个主要缺点是分布式系统而产生的复杂性。开发人员需要选择和实现基于消息传递或RPC的进程间通信机制。
此外，他们还必须编写代码来处理部分故障，因为请求的目的地可能很慢或不可用。

  3、微服务器的另一个挑战是分区数据库架构。更新多个业务实体的业务交易是相当普遍的。但是，在基于微服务器的应用程序中，需要更新不同服务所拥有的多个数据库。
使用分布式事务通常不是一个选择，而不仅仅是因为CAP定理。许多今天高度可扩展的NoSQL数据库都不支持它们。
你最终不得不使用最终的一致性方法，这对开发人员来说更具挑战性。

  4、测试微服务应用程序也更复杂。服务类似的测试类将需要启动该服务及其所依赖的任何服务（或至少为这些服务配置存根）。再次，重要的是不要低估这样做的复杂性。

  5、Microservice架构模式的另一个主要挑战是实现跨越多个服务的更改。
例如，我们假设正在实施一个需要更改服务A，B和C的故事，其中A取决于B和B取决于C.在单片应用程序中，你可以简单地更改相应的模块，整合更改，并一次性部署。
相比之下，在Microservice架构模式中，您需要仔细规划和协调对每个服务的更改。例如，您需要更新服务C，然后更新服务B，然后再更新A。
幸运的是，大多数更改通常仅影响一个服务，而需要协调的多服务变更相对较少。

  6、部署基于微服务的应用程序也更复杂。单一应用程序简单地部署在传统负载平衡器后面的一组相同的服务器上。
每个应用程序实例都配置有基础架构服务（如数据库和消息代理）的位置（主机和端口）。相比之下，微服务应用通常由大量服务组成。
例如，每个服务将有多个运行时实例。更多的移动部件需要进行配置，部署，扩展和监控。
此外，还需要实现服务发现机制，使服务能够发现需要与之通信的任何其他服务的位置（主机和端口）。
传统的基于故障单和手动操作的方法无法扩展到这种复杂程度。因此，成功部署微服务应用程序需要开发人员更好地控制部署方法，并实现高水平的自动化
```

---
### <a id="a_27">2.7、相关扩展</a> <a href="#a_26">last</a> <a href="#a_22">next</a>
1、微服务思考：
```
微服务对我们的思考，更多的是思维上的转变。对于微服务架构：技术上不是问题，意识比工具重要。
```
2、关于微服务的几点设计出发点：
```
  1、应用程序的核心是业务逻辑，按照业务或客户需求组织资源（这是最难的）
  2、做有生命的产品，而不是项目
  3、全栈化
  4、后台服务贯彻：Single Responsibility Principle（单一职责原则）
  5、应用容器引擎：VM -> Docker 
  6、DevOps
  同时，有这么多的中间件和强大的工程师支持固然是好事，我们也需要深入去了解这些中间件背后的原理，知其然知其所以然，在有限的技术资源如何通过开源技术实施微服务。
  最后，一般提到微服务都离不开DevOps和Docker，理解微服务架构是核心，devops和docker是工具，是手段
```

---
<a id="a_down"></a>  
<a href="#a_top">Top</a> 
<a href="#a_catalogue">Catalogue</a>