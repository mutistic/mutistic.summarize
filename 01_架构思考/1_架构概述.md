# <a id="a_top">1、架构概述</a> [分布式架构思考]() [2、RPC服务]()

---
### <a id="a_catalogue">目录</a>：
1. <a href="#a_01">一、分布式架构</a>
2. <a href="#a_11">为什么需要分布式架构</a>
3. <a href="#a_12">理解单体架构</a>
4. <a href="#a_13">理解分布式架构</a>
5. <a href="#a_14">分布式架构的特征</a>
6. <a href="#a_15">理论/思想</a>
7. <a href="#a_16">关键词</a>
8. <a href="#a_02">二、微服务架构</a>
9. <a href="#a_21">什么是微服务架构</a>
10. <a href="#a_22">微服务的出现与发展</a>
11. <a href="#a_23">微服务的特征</a>
12. <a href="#a_24">如何具体实践微服务</a>
13. <a href="#a_25">常见的微服务设计模式和应用</a>
14. <a href="#a_26">微服务的优点和缺点</a>
15. <a href="#a_27">相关扩展</a>
99. <a href="#a_down">down</a>

|作者|Mutistic|
|---|---|
|邮箱|mutistic@qq.com|

---
## <a id="a_01">一、分布式架构：</a> <a href="#a_catalogue">目录</a> <a href="#a_02">二、微服务架构</a>
### <a id="a_11">1.1、为什么需要分布式架构：</a> <a href="#a_12">next</a>
```
  谈到分布式架构，首先要明白的为什么要从单体架构改造成分布式架构，那么单体架构的优劣是什么，而分布式架构在此中解决了什么问题，而又引发了什么问题？
```

---
### <a id="a_12">1.2、理解单体架构：</a> <a href="#a_11">last</a> <a href="#a_13">next</a>
1、什么是单体架构：
```
  一般而言，将一整套系统集中部署在单服务器上，对外提供服务，可以认为是单体架构。
  
  在最初的系统设计中，是没有对项目进行模块化、微服务化、分布式部署，各种代码一般都集中在一个工程项目中，工程项目会变得越发庞大
```
2、单体架构的优点：
```
  显著的优点是成本低，没有分布式架构中的一些弊端，技术体系相对而言较低
```
3、单体架构的缺点：
```
  系统容易出现性能瓶颈，项目耦合度过高导致维护成本比较高，系统的可用性相对而言不高，对横向扩展支持比较差（扩展性差），不能灵活进行分布式部署。
```

---
### <a id="a_13">1.3、理解分布式架构：</a> <a href="#a_12">last</a> <a href="#a_14">next</a>
1、什么是分布式架构：
```
  广泛的定义：分布式架构是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。
  
  所谓的节点是指一台服务器，这些节点通过网络相互连通，然后软件部署在这些节点上，进行协同工作。
```

2、分布式架构的目的：
```
  什么情景下引入分布式架构：
    当单体架构的处理能力无法满足日益增长的业务、计算、存储任等需求，单服务器的纵向扩展比如硬件的提升（加内存、硬盘容量、固态硬盘、高性能CPU） 成本高昂，
应用系统无法通过优化解决这些问题时，我们才考虑分布式架构，分布式架构与单体架构解决的问题是一致的，而分布式架构的只是在技术层面优化单体架构的缺点。

  分布式架构的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。
  
  其目的是利用更多的机器，处理更多的数据
```

3、分布式架构的优点：
```
  提升系统的性能和并发、提升系统的可用性、使得横向扩展变得简单、降低系统的耦合度、提高开发效率、可以进行分布式部署、独立部署
```

4、分布式架构的缺点：
```
  分布式架构会带来更多的技术栈、学习成本高、不可靠的网络问题、异构的机器与网络、普遍的节点故障、测试成本提高
```

5、比较分布式架构和单体架构：

| |传统单体架构|分布式服务化框架|
|---|---|---|
|新功能开发|需要开发|容易开发和实现|
|部署|不经常部署且容易部署|经常发布，部署复杂|
|隔离性|故障影响范围大|故障影响范围小|
|架构设计|难度小|难度级数增加|
|系统性能|响应时间快，吞吐量小|响应时间慢，吞吐量大|
|系统运维|运维简单|运维复杂|
|上手掌握|应用逻辑学习曲线大|架构逻辑学习曲线大|
|技术|技术单一且封闭|技术多样性且开放|
|测试和纠错|简单|复杂|
|系统扩展性|扩展性差|扩展性好|
|系统管理|重点在开发成本|重点在服务治理和|

6、分布式架构引发的问题：
```
  服务节点管理、负载均衡、双主问题（脑裂问题）、数据均衡分布、数据一致性、网络问题、session共享、分布式事务等问题
```

---
### <a id="a_14">1.4、分布式架构的特征：</a> <a href="#a_13">last</a> <a href="#a_15">next</a>
1、可扩展性：
```
  可扩展性指当架构的任务增加的时候，通过增加资源来应对任务增长的能力。
  扩展性的目标是使得系统中的节点都在一个较为稳定的负载下工作，这就是负载均衡，当然，
在动态增加节点的时候，需要进行任务（可能是计算或数据存储）的迁移，以达到动态均衡
```

2、高性能：
```
  分布式系统的理想目标是任务与节点按一定的比例线性增长
```

3、高可用：
```
  可用性（Availability）是架构不间断对外提供服务的能力，可用性是一个度的问题，最高目标就是7 * 24，即永远在线，
但事实上做不到的，一般是用几个9来衡量系统的可用性。
  
  4个九特指一年中系统的可用性为99.99%
```

4：[一致性](https://www.cnblogs.com/biterror/p/6909624.html):
```
  从系统角度的一致性：强一致性、弱一致性、最终一致性
  从用户角度的一致性：单调读一致性，单调写一致性，读后写一致性，写后读一致性
```

---
### <a id="a_15">1.5、理论/思想：</a> <a href="#a_14">last</a> <a href="#a_16">next</a>
1、[摩尔定律](https://baike.baidu.com/item/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B)：
```
  价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，
将每隔18-24个月翻一倍以上。
  这一定律揭示了信息技术进步的速度
```

2、[CAP定理](https://baike.baidu.com/item/CAP%E5%AE%9A%E7%90%86)：
```
  CAP定理（CAP theorem），又称CAP原则和作布鲁尔定理（Brewer's theorem）：

  1、一致性（C：Consistency）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。即数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。
同时，一致性也是指事务的基本特征或特性相同，其他特性或特征相类似。

  2、可用性（A：Availability）：在集群（由多个独立的计算机通过高速的通信网络连接起来的,具有单一系统映象的高性能计算机系统）中一部分节点故障后，
集群整体是否还能响应客户端的读写请求。（可用性不仅包括读，还有写）
  
  3、分区容忍性（P：Partition tolerance）：集群中的某些节点在无法联系后，集群整体是否还能继续进行服务。
系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择
```

3、[ACID](https://baike.baidu.com/item/acid/10738)：
```
   ACID，指数据库事务正确执行的四个基本要素的缩写，包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
   一个支持事务（Transaction）的数据库，必须要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性
   
   1、原子性（A：Atomicity）：
   整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。
   事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样
   
   2、一致性（C：Consistency）：
   一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少
   也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)
   
   3、隔离性（I：Isolation）：
   隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。
   这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据
   
   4、持久性（D：Durability）：
   在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。
   由于一项操作通常会包含许多子操作，而这些子操作可能会因为硬件的损坏或其他因素产生问题，要正确实现ACID并不容易。
   ACID建议数据库将所有需要更新以及修改的资料一次操作完毕，但实际上并不可行。
  
   目前主要有两种方式实现ACID：第一种是WAL（Write ahead logging，日志式的方式），现代数据库均基于这种方式。第二种是Shadow paging（影子分页技术）
   4.1、WAL 的中心思想是对数据文件的修改（它们是表和索引的载体）必须是只能发生在这些修改已经记录了日志之后，
   也就是说，在日志记录冲刷到永久存储器之后．如果我们遵循这个过程，那么我们就不需要在每次事务提交的时候 都把数据页冲刷到磁盘，
   因为我们知道在出现崩溃的情况下，我们可以用日志来恢复数据库：
   任何尚未附加到数据页的记录 都将先从日志记录中重做（这叫向前滚动恢复，也叫做 REDO） 
   然后那些未提交的事务做的修改将被从数据页中删除 （这叫向后滚动恢复 - UNDO）
  
   4.2、相对于WAL（write ahead logging）技术，shadow paging技术实现起来比较简单，消除了写日志记录的开销恢复的速度也快(不需要redo和undo)。
   shadow paging的缺点就是事务提交时要输出多个块，这使得提交的开销很大，而且以块为单位，很难应用到允许多个事务并发执行的情况——这是它致命的缺点。
```

4、BASE思想：
```
  BASE思想主要强调基本的可用性，如果你需要高可用性，也就是纯粹的高性能，那么就要以一致性或容错性为牺牲
  
  BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性： 
  1、基本可用(BA：Basically Available）：支持分区失败(如，sharding碎片划分数据库) 
  2、软状态/柔性事务（S：Soft state）：状态可以有一段时间不同步，异步。 Soft state 可以理解为无连接的, 而 Hard state 是面向连接的 
  3、最终一致（E：Eventually consistent）：最终数据是一致的就可以了，而不是时时一致。最终一致性，也是是 ACID 的最终目的
  
  BASE思想的主要实现有：
  1.按功能划分数据库
  2.sharding碎片
```

---
### <a id="a_16">1.6、关键词：</a> <a href="#a_15">last</a> <a href="#a_21">next</a>
```
  节点，时间，一致性，CAP，ACID，BASE，P2P，机器伸缩，网络变更，负载均衡，限流，鉴权，服务发现，服务编排，降级，熔断，
  幂等，分库分表，分片分区，自动运维，容错处理，全栈监控，故障恢复，性能调优
```


---
## <a id="a_02">二、微服务架构：</a> <a href="#a_01">一、分布式架构</a> <a href="#a_03">三、</a>
### <a id="a_21">2.1、什么是微服务架构</a> <a href="#a_16">next</a> <a href="#a_22">next</a>
```
  微服务架构（Microservice Architecture）：是一种架构概念，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。
你可以将其看作是在架构层次而非获取服务的类上应用很多SOLID原则（面向对象设计原则）。
微服务架构是个很有趣的概念，它的主要作用是将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。

  概念：把一个大型的单个应用程序和服务拆分为数个甚至数十个的支持微服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。

  定义：围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代。在分散的组件中使用云架构和平台式部署、管理和服务功能，使产品交付变得更加简单。

  本质：用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题
```

---
### <a id="a_22">2.2、微服务的出现与发展</a> <a href="#a_21">last</a> <a href="#a_23">next</a>
```
  微服务（Microservice）这个概念是2012年出现的，作为加快Web和移动应用程序开发进程的一种方法，2014年开始受到各方的关注，而2015年，可以说是微服务的元年；
越来越多的论坛、社区、blog以及互联网行业巨头开始对微服务进行讨论、实践，可以说这样更近一步推动了微服务的发展和创新。而微服务的流行，Martin Fowler功不可没，他特别擅长抽象归纳和制造概念。特别是微服务这种新生的名词，都有一个特点：一解释就懂，一问就不知，一讨论就打架

  Martin Fowler是国际著名的OO专家，敏捷开发方法的创始人之一，现为ThoughtWorks公司的首席科学家。
在面向对象分析设计、UML、模式、软件开发方法学、XP、重构等方面，都是世界顶级的专家，现为Thought Works公司的首席科学家。
Thought Works是一家从事企业应用开发和——集成的公司。
早在20世纪80年代，Fowler就是使用对象技术构建多层企业应用的倡导者，他著有几本经典书籍： 《企业应用架构模式》、《UML精粹》和《重构》等
```

---
### <a id="a_23">2.3、微服务的特征</a> <a href="#a_22">last</a> <a href="#a_24">next</a>
官方的定义：
```
  1、一些列的独立的服务共同组成系统
  2、单独部署，跑在自己的进程中
  3、每个服务为独立的业务开发
  4、分布式管理
  5、非常强调隔离性
```
大概的标准：
```
  1、分布式服务组成的系统
  2、按照业务，而不是技术来划分组织
  3、做有生命的产品而不是项目
  4、强服务个体和弱通信（ Smart endpoints and dumb pipes ）
  5、自动化运维（ DevOps ）
  6、高度容错性
  7、快速演化和迭代
```

---
### <a id="a_24">2.4、如何具体实践微服务</a> <a href="#a_23">last</a> <a href="#a_25">next</a>

---
### <a id="a_25">2.5、常见的微服务设计模式和应用</a> <a href="#a_24">last</a> <a href="#a_26">next</a>

---
### <a id="a_26">2.6、微服务的优点和缺点</a> <a href="#a_25">last</a> <a href="#a_27">next</a>

---
### <a id="a_27">2.7、相关扩展</a> <a href="#a_26">last</a> <a href="#a_22">next</a>

---
<a id="a_down"></a>  
<a href="#a_top">Top</a> 
<a href="#a_catalogue">Catalogue</a>