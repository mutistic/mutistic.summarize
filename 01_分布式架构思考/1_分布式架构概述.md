# <a id="a_top">1、分布式架构概述</a> [分布式架构思考]() [2、RPC服务]()

---
### <a id="a_catalogue">目录</a>：
1. <a href="#a_01">一、分布式架构</a>
2. <a href="#a_11">为什么需要分布式架构</a>
3. <a href="#a_12">理解单体架构</a>
4. <a href="#a_13">理解分布式架构</a>
5. <a href="#a_14">分布式架构的特征</a>
6. <a href="#a_15">理论/思想</a>
7. <a href="#a_16">关键词</a>
8. <a href="#a_02">二、微服务架构</a>
99. <a href="#a_down">down</a>

|作者|Mutistic|
|---|---|
|邮箱|mutistic@qq.com|

---
## <a id="a_01">一、分布式架构：</a> <a href="#a_catalogue">目录</a> <a href="#a_02">二、微服务架构</a>
### <a id="a_11">1.1、为什么需要分布式架构：</a> <a href="#a_12">next</a>
```
  谈到分布式架构，首先要明白的为什么要从单体架构改造成分布式架构，那么单体架构的优劣是什么，而分布式架构在此中解决了什么问题，而又引发了什么问题？
```

---
### <a id="a_12">1.2、理解单体架构：</a> <a href="#a_11">last</a> <a href="#a_13">next</a>
1、什么是单体架构：
```
  一般而言，将一整套系统集中部署在单服务器上，对外提供服务，可以认为是单体架构。
  
  在最初的系统设计中，是没有对项目进行模块化、微服务化、分布式部署，各种代码一般都集中在一个工程项目中，工程项目会变得越发庞大
```
2、单体架构的优点：
```
  显著的优点是成本低，没有分布式架构中的一些弊端，技术体系相对而言较低
```
3、单体架构的缺点：
```
  系统容易出现性能瓶颈，项目耦合度过高导致维护成本比较高，系统的可用性相对而言不高，对横向扩展支持比较差（扩展性差），不能灵活进行分布式部署。
```

---
### <a id="a_13">1.3、理解分布式架构：</a> <a href="#a_12">last</a> <a href="#a_14">next</a>
1、什么是分布式架构：
```
  广泛的定义：分布式架构是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。
  
  所谓的节点是指一台服务器，这些节点通过网络相互连通，然后软件部署在这些节点上，进行协同工作。
```

2、分布式架构的目的：
```
  什么情景下引入分布式架构：
    当单体架构的处理能力无法满足日益增长的业务、计算、存储任等需求，单服务器的纵向扩展比如硬件的提升（加内存、硬盘容量、固态硬盘、高性能CPU） 成本高昂，
应用系统无法通过优化解决这些问题时，我们才考虑分布式架构，分布式架构与单体架构解决的问题是一致的，而分布式架构的只是在技术层面优化单体架构的缺点。

  分布式架构的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。
  
  其目的是利用更多的机器，处理更多的数据
```

3、分布式架构的优点：
```
  提升系统的性能和并发、提升系统的可用性、使得横向扩展变得简单、降低系统的耦合度、提高开发效率、可以进行分布式部署、独立部署
```

4、分布式架构的缺点：
```
  分布式架构会带来更多的技术栈、学习成本高、不可靠的网络问题、异构的机器与网络、普遍的节点故障、测试成本提高
```

5、比较分布式架构和单体架构：

| |传统单体架构|分布式服务化框架|
|---|---|---|
|新功能开发|需要开发|容易开发和实现|
|部署|不经常部署且容易部署|经常发布，部署复杂|
|隔离性|故障影响范围大|故障影响范围小|
|架构设计|难度小|难度级数增加|
|系统性能|响应时间快，吞吐量小|响应时间慢，吞吐量大|
|系统运维|运维简单|运维复杂|
|上手掌握|应用逻辑学习曲线大|架构逻辑学习曲线大|
|技术|技术单一且封闭|技术多样性且开放|
|测试和纠错|简单|复杂|
|系统扩展性|扩展性差|扩展性好|
|系统管理|重点在开发成本|重点在服务治理和|

6、分布式架构引发的问题：
```
  服务节点管理、负载均衡、双主问题（脑裂问题）、数据均衡分布、数据一致性、网络问题、session共享、分布式事务等问题
```

---
### <a id="a_14">1.4、分布式架构的特征：</a> <a href="#a_13">last</a> <a href="#a_15">next</a>
1、可扩展性：
```
  可扩展性指当架构的任务增加的时候，通过增加资源来应对任务增长的能力。
  扩展性的目标是使得系统中的节点都在一个较为稳定的负载下工作，这就是负载均衡，当然，
在动态增加节点的时候，需要进行任务（可能是计算或数据存储）的迁移，以达到动态均衡
```

2、高性能：
```
  分布式系统的理想目标是任务与节点按一定的比例线性增长
```

3、高可用：
```
  可用性（Availability）是架构不间断对外提供服务的能力，可用性是一个度的问题，最高目标就是7 * 24，即永远在线，
但事实上做不到的，一般是用几个9来衡量系统的可用性。
  
  4个九特指一年中系统的可用性为99.99%
```

4：[一致性](https://www.cnblogs.com/biterror/p/6909624.html):
```
  从系统角度的一致性：强一致性、弱一致性、最终一致性
  从用户角度的一致性：单调读一致性，单调写一致性，读后写一致性，写后读一致性
```

---
### <a id="a_15">1.5、理论/思想：</a> <a href="#a_14">last</a> <a href="#a_16">next</a>
1、[摩尔定律](https://baike.baidu.com/item/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B)：
```
  价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，
将每隔18-24个月翻一倍以上。
  这一定律揭示了信息技术进步的速度
```

1、[CAP定理](https://baike.baidu.com/item/CAP%E5%AE%9A%E7%90%86)：
```
  CAP定理（CAP theorem），又称CAP原则和作布鲁尔定理（Brewer's theorem）：

  1、一致性（C：Consistency）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。即数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。
同时，一致性也是指事务的基本特征或特性相同，其他特性或特征相类似。

  2、可用性（A：Availability）：在集群（由多个独立的计算机通过高速的通信网络连接起来的,具有单一系统映象的高性能计算机系统）中一部分节点故障后，
集群整体是否还能响应客户端的读写请求。（可用性不仅包括读，还有写）
  
  3、分区容忍性（P：Partition tolerance）：集群中的某些节点在无法联系后，集群整体是否还能继续进行服务。
系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择
```

2、[ACID](https://baike.baidu.com/item/acid/10738)：
```
   ACID，指数据库事务正确执行的四个基本要素的缩写，包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
   一个支持事务（Transaction）的数据库，必须要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性
   
   1、原子性（A：Atomicity）：
   整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。
   事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样
   
   2、一致性（C：Consistency）：
   一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少
   也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)
   
   3、隔离性（I：Isolation）：
   隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。
   这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据
   
   4、持久性（D：Durability）：
   在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。
   由于一项操作通常会包含许多子操作，而这些子操作可能会因为硬件的损坏或其他因素产生问题，要正确实现ACID并不容易。
   ACID建议数据库将所有需要更新以及修改的资料一次操作完毕，但实际上并不可行。
  
   目前主要有两种方式实现ACID：第一种是WAL（Write ahead logging，日志式的方式），现代数据库均基于这种方式。第二种是Shadow paging（影子分页技术）
   4.1、WAL 的中心思想是对数据文件 的修改（它们是表和索引的载体）必须是只能发生在这些修改已经 记录了日志之后也就是说，在日志记录冲刷到永久存储器之后．
   如果我们遵循这个过程，那么我们就不需要在每次事务提交的时候 都把数据页冲刷到磁盘，因为我们知道在出现崩溃的情况下， 
   我们可以用日志来恢复数据库：任何尚未附加到数据页的记录 都将先从日志记录中重做（这叫向前滚动恢复，也叫做 REDO） 
   然后那些未提交的事务做的修改将被从数据页中删除 （这叫向后滚动恢复 - UNDO）
  
   4.2、相对于WAL（write ahead logging）技术，shadow paging技术实现起来比较简单，消除了写日志记录的开销恢复的速度也快(不需要redo和undo)。
   shadow paging的缺点就是事务提交时要输出多个块，这使得提交的开销很大，而且以块为单位，很难应用到允许多个事务并发执行的情况——这是它致命的缺点。
```

3、BASE思想：
```
  BASE思想主要强调基本的可用性，如果你需要高可用性，也就是纯粹的高性能，那么就要以一致性或容错性为牺牲
  
  BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性： 
  1、基本可用(BA：Basically Available）：支持分区失败(如，sharding碎片划分数据库) 
  2、软状态/柔性事务（S：Soft state）：状态可以有一段时间不同步，异步。 Soft state 可以理解为无连接的, 而 Hard state 是面向连接的 
  3、最终一致（E：Eventually consistent）：最终数据是一致的就可以了，而不是时时一致。最终一致性，也是是 ACID 的最终目的
  
  BASE思想的主要实现有：
  1.按功能划分数据库
  2.sharding碎片
```

---
### <a id="a_16">1.6、关键词：</a> <a href="#a_15">last</a> <a href="#a_02">next</a>
```
  节点，时间，一致性，CAP，ACID，BASE，P2P，机器伸缩，网络变更，负载均衡，限流，鉴权，服务发现，服务编排，降级，熔断，
  幂等，分库分表，分片分区，自动运维，容错处理，全栈监控，故障恢复，性能调优
```


---
## <a id="a_02">二、微服务架构：</a> <a href="#a_01">一、分布式架构</a> <a href="#a_03">三、</a>
### <a id="a_21">2.1、</a> <a href="#a_22">next</a>

---
<a id="a_down"></a>  
<a href="#a_top">Top</a> 
<a href="#a_catalogue">Catalogue</a>