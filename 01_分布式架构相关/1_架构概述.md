# <a id="a_top">1、架构概述</a> [分布式架构思考]() [2、RPC服务]()

### <a id="a_catalogue">目录</a>：
1. <a href="#a_01">一、分布式架构</a>
2. <a href="#a_11">为什么需要分布式架构</a>
3. <a href="#a_12">理解单体架构</a>
4. <a href="#a_13">理解分布式架构</a>
5. <a href="#a_14">分布式架构的特征</a>
6. <a href="#a_15">理论/思想</a>
7. <a href="#a_16">关键词</a>
8. <a href="#a_02">二、微服务架构</a>
9. <a href="#a_21">什么是微服务架构</a>
10. <a href="#a_22">微服务的出现与发展</a>
11. <a href="#a_23">微服务的特征</a>
12. <a href="#a_24">如何具体实践微服务</a>
13. <a href="#a_25">常见的微服务设计模式和应用</a>
14. <a href="#a_26">微服务的优点和缺点</a>
15. <a href="#a_27">相关扩展</a>
16. <a href="#a_03">三、简单理解几种架构</a>
17. <a href="#a_31">SOA架构</a>
18. <a href="#a_32">集群架构</a>
19. <a href="#a_33">几种架构对比</a>
20. <a href="#a_04">三、简单理解几种架构</a>
99. <a href="#a_down">down</a>

|作者|Mutistic|
|---|---|
|邮箱|mutistic@qq.com|

---
## <a id="a_01">一、分布式架构：</a> <a href="#a_catalogue">目录</a> <a href="#a_02">二、微服务架构</a>
### <a id="a_11">1.1、为什么需要分布式架构：</a> <a href="#a_12">next</a>
```
  谈到分布式架构，首先要明白的为什么要从单体架构改造成分布式架构，那么单体架构的优劣是什么，而分布式架构在此中解决了什么问题，而又引发了什么问题？
```

---
### <a id="a_12">1.2、理解单体架构：</a> <a href="#a_11">last</a> <a href="#a_13">next</a>
1、什么是单体架构：
```
  一般而言，将一整套系统集中部署在单服务器上，对外提供服务，可以认为是单体架构。

  一个归档包（例如war格式或者Jar格式）包含了应用所有功能的应用程序，我们通常称之为单体应用。架构单体应用的方法论，我们称之为单体应用架构，这是一种比较传统的架构风格
  
  在最初的系统设计中，是没有对项目进行模块化、微服务化、分布式部署，各种代码一般都集中在一个工程项目中，工程项目会变得越发庞大
```
2、单体架构的优点：
```
  显著的优点是成本低，没有分布式架构中的一些弊端，技术体系相对而言较低
```
3、单体架构的缺点：
```
  系统容易出现性能瓶颈，项目耦合度过高导致维护成本比较高，系统的可用性相对而言不高，对横向扩展支持比较差（扩展性差），不能灵活进行分布式部署。

  1.复杂性高：整个项目包含的模块非常多，模块的边界模糊，依赖关系不清晰，代码质量参差不齐,整个项目非常复杂。
每次修改代码都心惊胆战，甚至添加一个简单的功能，或者修改一个BUG都会造成隐含的缺陷。

  2.技术债务逐渐上升：随着时间推移、需求变更和人员更迭，会逐渐形成应用程序的技术债务，并且越积越多。已使用的系统设计或代码难以修改，
因为应用程序的其他模块可能会以意料之外的方式使用它。

  3.部署速度逐渐变慢：随着代码的增加，构建和部署的时间也会增加。而在单体应用中，每次功能的变更或缺陷的修复都会导致我们需要重新部署整个应用。
全量部署的方式耗时长、影响范围大、风险高，这使得单体应用项目上线部署的频率较低，从而又导致两次发布之间会有大量功能变更和缺陷修复，出错概率较高。
  
  4.扩展能力受限，无法按需伸缩：单体应用只能作为一个整体进行扩展，无法结合业务模块的特点进行伸缩。
  
  5.阻碍技术创新：单体应用往往使用统一的技术平台或方案解决所有问题，团队的每个成员都必须使用相同的开发语言和架构，想要引入新的框架或技术平台非常困难。
```

---
### <a id="a_13">1.3、理解分布式架构：</a> <a href="#a_12">last</a> <a href="#a_14">next</a>
1、什么是分布式架构：
```
  广泛的定义：分布式架构是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。
  
  所谓的节点是指一台服务器，这些节点通过网络相互连通，然后软件部署在这些节点上，进行协同工作。
```

2、分布式架构的目的：
```
  什么情景下引入分布式架构：
    当单体架构的处理能力无法满足日益增长的业务、计算、存储任等需求，单服务器的纵向扩展比如硬件的提升（加内存、硬盘容量、固态硬盘、高性能CPU） 成本高昂，
应用系统无法通过优化解决这些问题时，我们才考虑分布式架构，分布式架构与单体架构解决的问题是一致的，而分布式架构的只是在技术层面优化单体架构的缺点。

  分布式架构的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。
  
  其目的是利用更多的机器，处理更多的数据
```

3、分布式架构的优点：
```
  提升系统的性能和并发、提升系统的可用性、使得横向扩展变得简单、降低系统的耦合度、提高开发效率、可以进行分布式部署、独立部署
```

4、分布式架构的缺点：
```
  分布式架构会带来更多的技术栈、学习成本高、不可靠的网络问题、异构的机器与网络、普遍的节点故障、测试成本提高
```

5、比较分布式架构和单体架构：

| |传统单体架构|分布式服务化框架|
|---|---|---|
|新功能开发|需要开发|容易开发和实现|
|部署|不经常部署且容易部署|经常发布，部署复杂|
|隔离性|故障影响范围大|故障影响范围小|
|架构设计|难度小|难度级数增加|
|系统性能|响应时间快，吞吐量小|响应时间慢，吞吐量大|
|系统运维|运维简单|运维复杂|
|上手掌握|应用逻辑学习曲线大|架构逻辑学习曲线大|
|技术|技术单一且封闭|技术多样性且开放|
|测试和纠错|简单|复杂|
|系统扩展性|扩展性差|扩展性好|
|系统管理|重点在开发成本|重点在服务治理和|

6、分布式架构引发的问题：
```
  服务节点管理、负载均衡、双主问题（脑裂问题）、数据均衡分布、数据一致性、网络问题、session共享、分布式事务等问题
```

---
### <a id="a_14">1.4、分布式架构的特征：</a> <a href="#a_13">last</a> <a href="#a_15">next</a>
1、可扩展性：
```
  可扩展性指当架构的任务增加的时候，通过增加资源来应对任务增长的能力。
  扩展性的目标是使得系统中的节点都在一个较为稳定的负载下工作，这就是负载均衡，当然，
在动态增加节点的时候，需要进行任务（可能是计算或数据存储）的迁移，以达到动态均衡
```

2、高性能：
```
  分布式系统的理想目标是任务与节点按一定的比例线性增长
```

3、高可用：
```
  可用性（Availability）是架构不间断对外提供服务的能力，可用性是一个度的问题，最高目标就是7 * 24，即永远在线，
但事实上做不到的，一般是用几个9来衡量系统的可用性。
  
  4个九特指一年中系统的可用性为99.99%
```

4：[一致性](https://www.cnblogs.com/biterror/p/6909624.html):
```
  从系统角度的一致性：强一致性、弱一致性、最终一致性
  从用户角度的一致性：单调读一致性，单调写一致性，读后写一致性，写后读一致性
```

---
### <a id="a_15">1.5、理论/思想：</a> <a href="#a_14">last</a> <a href="#a_16">next</a>
1、[摩尔定律](https://baike.baidu.com/item/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B)：
```
  价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，
将每隔18-24个月翻一倍以上。
  这一定律揭示了信息技术进步的速度
```

2、[CAP定理](https://baike.baidu.com/item/CAP%E5%AE%9A%E7%90%86)：
```
  CAP定理（CAP theorem），又称CAP原则和作布鲁尔定理（Brewer's theorem）：

  1、一致性（C：Consistency）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。即数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。
同时，一致性也是指事务的基本特征或特性相同，其他特性或特征相类似。

  2、可用性（A：Availability）：在集群（由多个独立的计算机通过高速的通信网络连接起来的,具有单一系统映象的高性能计算机系统）中一部分节点故障后，
集群整体是否还能响应客户端的读写请求。（可用性不仅包括读，还有写）
  
  3、分区容忍性（P：Partition tolerance）：集群中的某些节点在无法联系后，集群整体是否还能继续进行服务。
系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择
```

3、[ACID](https://baike.baidu.com/item/acid/10738)：
```
   ACID，指数据库事务正确执行的四个基本要素的缩写，包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
   一个支持事务（Transaction）的数据库，必须要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性
   
   1、原子性（A：Atomicity）：
   整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。
   事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样
   
   2、一致性（C：Consistency）：
   一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少
   也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)
   
   3、隔离性（I：Isolation）：
   隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。
   这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据
   
   4、持久性（D：Durability）：
   在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。
   由于一项操作通常会包含许多子操作，而这些子操作可能会因为硬件的损坏或其他因素产生问题，要正确实现ACID并不容易。
   ACID建议数据库将所有需要更新以及修改的资料一次操作完毕，但实际上并不可行。
  
   目前主要有两种方式实现ACID：第一种是WAL（Write ahead logging，日志式的方式），现代数据库均基于这种方式。第二种是Shadow paging（影子分页技术）
   4.1、WAL 的中心思想是对数据文件的修改（它们是表和索引的载体）必须是只能发生在这些修改已经记录了日志之后，
   也就是说，在日志记录冲刷到永久存储器之后．如果我们遵循这个过程，那么我们就不需要在每次事务提交的时候 都把数据页冲刷到磁盘，
   因为我们知道在出现崩溃的情况下，我们可以用日志来恢复数据库：
   任何尚未附加到数据页的记录 都将先从日志记录中重做（这叫向前滚动恢复，也叫做 REDO） 
   然后那些未提交的事务做的修改将被从数据页中删除 （这叫向后滚动恢复 - UNDO）
  
   4.2、相对于WAL（write ahead logging）技术，shadow paging技术实现起来比较简单，消除了写日志记录的开销恢复的速度也快(不需要redo和undo)。
   shadow paging的缺点就是事务提交时要输出多个块，这使得提交的开销很大，而且以块为单位，很难应用到允许多个事务并发执行的情况——这是它致命的缺点。
```

4、BASE思想：
```
  BASE思想主要强调基本的可用性，如果你需要高可用性，也就是纯粹的高性能，那么就要以一致性或容错性为牺牲
  
  BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性： 
  1、基本可用(BA：Basically Available）：支持分区失败(如，sharding碎片划分数据库) 
  2、软状态/柔性事务（S：Soft state）：状态可以有一段时间不同步，异步。 Soft state 可以理解为无连接的, 而 Hard state 是面向连接的 
  3、最终一致（E：Eventually consistent）：最终数据是一致的就可以了，而不是时时一致。最终一致性，也是是 ACID 的最终目的
  
  BASE思想的主要实现有：
  1.按功能划分数据库
  2.sharding碎片
```

---
### <a id="a_16">1.6、关键词：</a> <a href="#a_15">last</a> <a href="#a_21">next</a>
```
  节点，时间，一致性，CAP，ACID，BASE，P2P，机器伸缩，网络变更，负载均衡，限流，鉴权，服务发现，服务编排，降级，熔断，
  幂等，分库分表，分片分区，自动运维，容错处理，全栈监控，故障恢复，性能调优
```

---
## <a id="a_02">二、微服务架构：</a> <a href="#a_01">一、分布式架构</a> <a href="#a_03">三、简单理解几种架构</a>
### <a id="a_21">2.1、什么是微服务架构</a> <a href="#a_16">next</a> <a href="#a_22">next</a>
```
  微服务架构（Microservice Architecture）：是一种架构概念，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。
你可以将其看作是在架构层次而非获取服务的类上应用很多SOLID原则（面向对象设计原则）。
微服务架构是个很有趣的概念，它的主要作用是将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。

  概念：把一个大型的单个应用程序和服务拆分为数个甚至数十个的支持微服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。

  定义：围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代。在分散的组件中使用云架构和平台式部署、管理和服务功能，使产品交付变得更加简单。

  本质：用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题
```

---
### <a id="a_22">2.2、微服务的出现与发展</a> <a href="#a_21">last</a> <a href="#a_23">next</a>
```
  微服务（Microservice）这个概念是2012年出现的，作为加快Web和移动应用程序开发进程的一种方法，2014年开始受到各方的关注，而2015年，可以说是微服务的元年；
越来越多的论坛、社区、blog以及互联网行业巨头开始对微服务进行讨论、实践，可以说这样更近一步推动了微服务的发展和创新。而微服务的流行，Martin Fowler功不可没，他特别擅长抽象归纳和制造概念。特别是微服务这种新生的名词，都有一个特点：一解释就懂，一问就不知，一讨论就打架

  Martin Fowler是国际著名的OO专家，敏捷开发方法的创始人之一，现为ThoughtWorks公司的首席科学家。
在面向对象分析设计、UML、模式、软件开发方法学、XP、重构等方面，都是世界顶级的专家，现为Thought Works公司的首席科学家。
Thought Works是一家从事企业应用开发和——集成的公司。
早在20世纪80年代，Fowler就是使用对象技术构建多层企业应用的倡导者，他著有几本经典书籍： 《企业应用架构模式》、《UML精粹》和《重构》等
```

---
### <a id="a_23">2.3、微服务的特征</a> <a href="#a_22">last</a> <a href="#a_24">next</a>
1、官方的定义：
```
  1、一些列的独立的服务共同组成系统
  2、单独部署，跑在自己的进程中
  3、每个服务为独立的业务开发
  4、分布式管理
  5、非常强调隔离性
```
2、大概的标准：
```
  1、分布式服务组成的系统
  2、按照业务，而不是技术来划分组织
  3、做有生命的产品而不是项目
  4、强服务个体和弱通信（ Smart endpoints and dumb pipes ）
  5、自动化运维（ DevOps ）
  6、高度容错性
  7、快速演化和迭代
```

---
### <a id="a_24">2.4、如何具体实践微服务</a> <a href="#a_23">last</a> <a href="#a_25">next</a>
1、要实际的应用微服务，需要解决一下四点问题：
```
  1、客户端如何访问这些服务
  2、每个服务之间如何通信
  3、如此多的服务，如何实现？
  4、服务挂了，如何解决？（备份方案，应急处理机制）
```
2、客户端如何访问这些服务：
```
  原来的单体(Monolithic)方式开发，所有的服务都是本地的，UI可以直接调用，现在按功能拆分成独立的服务，跑在独立的一般都在独立的虚拟机上的 Java进程了。
客户端UI如何访问他的？后台有N个服务，前台就需要记住管理N个服务，一个服务下线/更新/升级，前台就要重新部署，这明显不服务我们 拆分的理念，特别当前台是移动应用的时候，通常业务变化的节奏更快。

  另外，N个小服务的调用也是一个不小的网络开销。还有一般微服务在系统内部，通常是无状态的，用户登录信息和权限管理最好有一个统一的地方维护管理（OAuth）。

  所以，一般在后台N个服务和UI之间一般会一个代理或者叫API Gateway(API网关)，他的作用包括：
  1、提供统一服务入口，让微服务对前台透明
  2、聚合后台的服务，节省流量，提升性能
  3、提供安全，过滤，流控等API管理功能
  
  其实这个API Gateway可以有很多广义的实现办法，可以是一个软硬一体的盒子，也可以是一个简单的MVC框架，甚至是一个Node.js的服务端。
他们最重要的作 用是为前台（通常是移动应用）提供后台服务的聚合，提供一个统一的服务出口，解除他们之间的耦合。

  不过API Gateway也有可能成为单点故障点或者性能的瓶颈
```
![2.4.2_客户端访问服务方式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.4.2_%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E6%96%B9%E5%BC%8F.png)

3、每个服务之间如何通信：  
[RESTful 架构详解](https://www.runoob.com/w3cnote/restful-architecture.html)
```
  所有的微服务都是独立的Java进程跑在独立的虚拟机上，所以服务间的通信就是IPC（inter process communication），已经有很多成熟的方案。
现在基本最通用的有两种方式：
  1、同步调用：REST风格（JAX-RS，Spring Boot）、RPC风格（Thrift, Dubbo）
  2、异步消息调用：RocketMQ、RabbitMQ、Kafka、ActiveMQ
```
3.2、同步和异步的区别：
```
  1、同步：
  一般同步调用比较简单，一致性强，但是容易出调用问题，性能体验上也会差些，特别是调用层次多的时候。RESTful和RPC的比较也是一个很有意思的话题。
  一般REST基于HTTP，更容易实现，更容易被接受，服务端实现技术也更灵活些，各个语言都能支持，同时能跨客户端，对客户端没有特殊的要求，只要封装了HTTP的
SDK就能调用，所以相对使用的广一些。
  RPC也有自己的优点，传输协议更高效，安全更可控，特别在一个公司内部，如果有统一个的开发规范和统一的服务框架时，他的开发效率优势更明显些。
就看各自的技术积累实际条件和选择了。

  2、异步消息：
  异步消息的方式在分布式系统中有特别广泛的应用，他既能减低调用服务之间的耦合，又能成为调用之间的缓冲，确保消息积压不会冲垮被调用方，
同时能保证调用方的服务体验，继续干自己该干的活，不至于被后台性能拖慢。
  不过需要付出的代价是一致性的减弱，需要接受数据最终一致性；
  还有就是后台服务一般要 实现幂等性，因为消息发送出于性能的考虑一般会有重复（保证消息的被收到且仅收到一次对性能是很大的考验）；
  最后就是必须引入一个独立的broker，如果公司内部没有技术积累，对broker分布式管理也是一个很大的挑战
```
![2.4.3_服务间的通信方式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.4.3_%E6%9C%8D%E5%8A%A1%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.png)

4、如此多的服务，如何实现？
```
  在微服务架构中，一般每一个服务都是有多个拷贝，来做负载均衡。一个服务随时可能下线，也可能应对临时访问压力增加新的服务节点。

  服务之间如何相互感知？服务如何管理？这就是服务发现的问题了。一般有两类做法，也各有优缺点。
  基本都是通过zookeeper等类似技术做服务注册信息的分布式管理。
  1、当服务上线时，服务提供者将自己的服务信息注册到ZK（或类似框架），并通过心跳维持长链接，实时更新链接信息。
  2、服务调用者通过ZK寻址，根据可定制算法，找到一个服务，还可以将服务信息缓存在本地以提高性能。
  3、当服务下线时，ZK会发通知给服务客户端。
  
  客户端做：优点是架构简单，扩展灵活，只对服务注册器依赖。缺点是客户端要维护所有调用服务的地址，有技术难度，一般大公司都有成熟的内部框架支持，比如Dubbo。
  服务端做：优点是简单，所有服务对于前台调用方透明，一般在小公司在云服务上部署的应用采用的比较多
```
![2.4.4_服务的管理方式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.4.4_%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F.png)

5、服务挂了，如何解决：
```
  前面提到，Monolithic方式开发一个很大的风险是，把所有鸡蛋放在一个篮子里，一荣俱荣，一损俱损。
而分布式最大的特性就是网络是不可靠的。通过微服务拆分能降低这个风险，

  不过如果没有特别的保障，结局肯定是噩梦。所以当我们的系统是由一系列的服务调用链组成的时候，我们必须确保任一环节出问题都不至于影响整体链路。
  相应的手段有很多：重试机制、限流、熔断机制、负载均衡、降级（本地缓存）
  这些方法基本都很明确通用，比如Netflix的Hystrix
```
![2.4.5_服务容错方式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.4.5_%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E6%96%B9%E5%BC%8F.png)

---
### <a id="a_25">2.5、常见的微服务设计模式和应用</a> <a href="#a_24">last</a> <a href="#a_26">next</a>
1、总结微服务架构需要考虑的问题，包括：API Gateway、服务间调用、服务发现、服务容错、服务部署、数据调用  
![2.5.1_微服务架构需要考虑的问题](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.5.1_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98.png)

2、六种常见的微服务架构设计模式：  
2.1、聚合器微服务设计模式：
![2.5.2.1_聚合器微服务设计模式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.5.2.1_%E8%81%9A%E5%90%88%E5%99%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png)
```
  这是一种最常见也最简单的设计模式，聚合器调用多个服务实现应用程序所需的功能。它可以是一个简单的Web页面，将检索到的数据进行处理展示。
它也可以是一个更高层次的组合微服务，对检索到的数据增加业务逻辑后进一步

  发布成一个新的微服务，这符合DRY原则。另外，每个服务都有自己的缓存和数据库。
如果聚合器是一个组合服务，那么它也有自己的缓存和数据库。聚合器可以沿X轴和Z轴独立扩展
```
2.2、代理微服务设计模式：
![2.5.2.2_代理微服务设计模式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.5.2.2_%E4%BB%A3%E7%90%86%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png)
```
  这是聚合模式的一个变种，在这种情况下，客户端并不聚合数据，但会根据业务需求的差别调用不同的微服务。代理可以仅仅委派请求，也可以进行数据转换工作
```
2.3、链式微服务设计模式：
![2.5.2.3_链式微服务设计模式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.5.2.3_%E9%93%BE%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png)
```
  这种模式在接收到请求后会产生一个经过合并的响应，在这种情况下，服务A接收到请求后会与服务B进行通信，类似地，服务B会同服务C进行通信。
所有服务都使用同步消息传递。在整个链式调用完成之前，客户端会一直阻塞。因此，服务调用链不宜过长，以免客户端长时间等待
```
2.4、分支微服务设计模式：
![2.5.2.4_分支微服务设计模式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.5.2.4_%E5%88%86%E6%94%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png)
```
  这种模式是聚合器模式的扩展，允许同时调用两个微服务链
```
2.5、数据共享微服务设计模式：
![2.5.2.5_数据共享微服务设计模式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.5.2.5_%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png)
```
  自治是微服务的设计原则之一，就是说微服务是全栈式服务。但在重构现有的“单体应用（monolithic application）”时，SQL数据库反规范化可能会导致数据重复和不一致。
因此，在单体应用到微服务架构的过渡阶段，可以使用这种设计模式，在这种情况下，部分微服务可能会共享缓存和数据库存储。
不过，这只有在两个服务之间存在强耦合关系时才可以。对于基于微服务的新建应用程序而言，这是一种反模式
```
2.6、异步消息传递微服务设计模式：
![2.5.2.6_异步消息传递微服务设计模式](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_2.5.2.6_%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png)
```
  虽然REST设计模式非常流行，但它是同步的，会造成阻塞。因此部分基于微服务的架构可能会选择使用消息队列代替REST请求/响应。
```

---
### <a id="a_26">2.6、微服务的优点和缺点</a> <a href="#a_25">last</a> <a href="#a_27">next</a>
1、微服务的优点：
```
  关键点：复杂度可控，独立按需扩展，技术选型灵活，容错，可用性高
  1、它解决了复杂性的问题。它会将一种怪异的整体应用程序分解成一组服务。虽然功能总量 不变，但应用程序已分解为可管理的块或服务。
每个服务都以RPC或消息驱动的API的形式定义了一个明确的边界；Microservice架构模式实现了一个模块化水平。
  
  2、这种架构使每个服务都能够由专注于该服务的团队独立开发。开发人员可以自由选择任何有用的技术，只要该服务符合API合同。
当然，大多数组织都希望避免完全无政府状态并限制技术选择。然而，这种自由意味着开发人员不再有义务使用在新项目开始时存在的可能过时的技术。
在编写新服务时，他们可以选择使用当前的技术。此外，由于服务相对较小，因此使用当前技术重写旧服务变得可行。
  
  3、Microservice架构模式使每个微服务都能独立部署。开发人员不需要协调部署本地服务的变更。这些变化可以在测试后尽快部署。
例如，UI团队可以执行A | B测试，并快速迭代UI更改。Microservice架构模式使连续部署成为可能。
  
  4、Microservice架构模式使每个服务都可以独立调整。可以仅部署满足其容量和可用性限制的每个服务的实例数。此外，可以使用最符合服务资源要求的硬件。
```
 

2、微服务的缺点
```
  关键点（挑战）：多服务运维难度，系统部署依赖，服务间通信成本，数据一致性，系统集成测试，重复工作，性能监控等

  1、一个缺点是名称本身。术语Microservice过度强调服务规模。但重要的是要记住，这是一种手段，而不是主要目标。
微服务的目标是充分分解应用程序，以便于敏捷应用程序开发和部署。

  2、微服务器的另一个主要缺点是分布式系统而产生的复杂性。开发人员需要选择和实现基于消息传递或RPC的进程间通信机制。
此外，他们还必须编写代码来处理部分故障，因为请求的目的地可能很慢或不可用。

  3、微服务器的另一个挑战是分区数据库架构。更新多个业务实体的业务交易是相当普遍的。但是，在基于微服务器的应用程序中，需要更新不同服务所拥有的多个数据库。
使用分布式事务通常不是一个选择，而不仅仅是因为CAP定理。许多今天高度可扩展的NoSQL数据库都不支持它们。
你最终不得不使用最终的一致性方法，这对开发人员来说更具挑战性。

  4、测试微服务应用程序也更复杂。服务类似的测试类将需要启动该服务及其所依赖的任何服务（或至少为这些服务配置存根）。再次，重要的是不要低估这样做的复杂性。

  5、Microservice架构模式的另一个主要挑战是实现跨越多个服务的更改。
例如，我们假设正在实施一个需要更改服务A，B和C的故事，其中A取决于B和B取决于C.在单片应用程序中，你可以简单地更改相应的模块，整合更改，并一次性部署。
相比之下，在Microservice架构模式中，您需要仔细规划和协调对每个服务的更改。例如，您需要更新服务C，然后更新服务B，然后再更新A。
幸运的是，大多数更改通常仅影响一个服务，而需要协调的多服务变更相对较少。

  6、部署基于微服务的应用程序也更复杂。单一应用程序简单地部署在传统负载平衡器后面的一组相同的服务器上。
每个应用程序实例都配置有基础架构服务（如数据库和消息代理）的位置（主机和端口）。相比之下，微服务应用通常由大量服务组成。
例如，每个服务将有多个运行时实例。更多的移动部件需要进行配置，部署，扩展和监控。
此外，还需要实现服务发现机制，使服务能够发现需要与之通信的任何其他服务的位置（主机和端口）。
传统的基于故障单和手动操作的方法无法扩展到这种复杂程度。因此，成功部署微服务应用程序需要开发人员更好地控制部署方法，并实现高水平的自动化
```

---
### <a id="a_27">2.7、相关扩展</a> <a href="#a_26">last</a> <a href="#a_31">next</a>
1、微服务思考：
```
微服务对我们的思考，更多的是思维上的转变。对于微服务架构：技术上不是问题，意识比工具重要。
```
2、关于微服务的几点设计出发点：
```
  1、应用程序的核心是业务逻辑，按照业务或客户需求组织资源（这是最难的）
  2、做有生命的产品，而不是项目
  3、全栈化
  4、后台服务贯彻：Single Responsibility Principle（单一职责原则）
  5、应用容器引擎：VM -> Docker 
  6、DevOps
  同时，有这么多的中间件和强大的工程师支持固然是好事，我们也需要深入去了解这些中间件背后的原理，知其然知其所以然，在有限的技术资源如何通过开源技术实施微服务。
  最后，一般提到微服务都离不开DevOps和Docker，理解微服务架构是核心，devops和docker是工具，是手段
```

---
## <a id="a_03">三、简单理解几种架构：</a> <a href="#a_02">二、微服务架构</a> <a href="#a_04">四、架构技术选型</a>
### <a id="a_31">[3.1、SOA架构](https://baike.baidu.com/item/SOA/2140650)</a> <a href="#a_27">next</a> <a href="#a_32">next</a>
1、什么是SOA架构：
```
  SOA架构（Service-Oriented Architecture）作为一种面向服务的架构，是一种软件架构设计的模型和方法论。

  从业务角度来看，一切以最大化“服务”的价值为出发点，SOA利用企业现有的各种软件体系，重新整合并构建起一套新的软件架构。
这套软件架构能够随着业务的变化，随时灵活地结合现有服务，组成新软件，共同服务于整个企业的业务体系。
简单的理解，我们可以把SOA看作是模块化的组件，每个模块都可以实现独立功能，而不同模块之间的结合则可以提供不同的服务，模块之间的接口遵循统一标准，可以实现低成本的重构和重组。
在SOA的技术框架下，可以把杂乱无章的庞大系统整合成一个全面有序的系统，从而增加企业在业务发展过程中应用系统的灵活性，实现最大的IT资产利用率
```
2、定义介绍：
```
  面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。

  SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。
SOA可以看作是B/S模型、XML（标准通用标记语言的子集）/Web Service技术之后的自然延伸。

  SOA将能够帮助软件工程师们站在一个新的高度理解企业级架构中的各种组件的开发、部署形式，它将帮助企业系统架构者以更迅速、更可靠、更具重用性架构整个业务系统。
较之以往，以SOA架构的系统能够更加从容地面对业务的急剧变化。

  SOA系统是一种企业通用性架构，早期企业软件业界自己摸索了一套实践方式：ESB（Enterprise Service Bus，企业服务总线）
```
3、基本特征:
```
  SOA的实施具有几个鲜明的基本特征。实施SOA的关键目标是实现企业IT资产的最大化作用。要实现这一目标，就要在实施SOA的过程中牢记以下特征：
  可从企业外部访问、随时可用、粗粒度的服务接口分级、松散耦合、可重用的服务、
  服务接口设计管理、标准化的服务接口、支持各种消息模式、精确定义的服务契约
```
4、优点：
```
  SOA的主要优点概括为：IT能够更好更快地提供业务价值（Business Centric）、快速应变能力（Flexibility）、重用（Reusability）

  也可以细分为以下几个方面：
  1、服务之间通过简单、精确定义的接口进行通信，不涉及底层编程接口和通信模型。
  2、粗粒度性：粗粒度服务提供一项特定的业务功能，采用粗粒度服务接口的优点在于使用者和服务层之间不必再进行多次的往复，一次往复就足够了。
  3、松耦合性：松耦合性要求SOA架构中的不同服务之间应该保持一种松耦合 的关系，也就是应该保持一种相对独立无依赖的关系。
这样的好处有两点，首先是具有灵活性，其次当组成整个应用程序的服务内部结构和实现逐步地发生变化时， 系统可以继续地独立存在。
而紧耦合意味着应用程序的不同组件之间的接口与其功能和结构是紧密相连的，因而当需要对部分或整个应用程序进行某种形式的更改时 这种结构就显得非常脆弱。
  4、位置透明性：位置透明性要求SOA系统中的所有服务对于其调用者来说都是位置透明的，
也就是说，每个服务的调用者只需要知道想要调用的是哪一个服务，但并不需要知道所调用服务的物理位置在哪。
  5、协议无关性：协议无关性要求每一个服务都可以通过不同的协议来调用
```
5、缺点：
```
  1、可能无法实现统一：使数据的所有特点一致几乎不太可能实现。除了上述问题之外，与 “脏数据” 相关的问题也总是存在。
处理一致性是设计服务接口面临的巨大挑战之一。尴尬的事实是建立统一的服务接口是一件非常困难的事情

  2、可能需要做出改变：在某些情况下可能需要改变操作平台。当需要在 ERP 中作出改变时，供应商非常不情愿做出改变。如果组织决定在内部作出变革，服务资金必须考虑维护成本

  3、SOA系统风强调服务统一，这意味着数据层面的变动会影响到所有的业务，统一的服务中心对纵向扩展支持比较差，而且容易成为系统性能的瓶颈
```

### <a id="a_32">3.2、集群架构</a> <a href="#a_31">next</a> <a href="#a_33">next</a>
1、什么是集群：
```
  计算机集群简称”集群”，是一种计算机系统，它通过一组松散集成的计算机软件和/或硬件连接起来高度紧密地协作完成计算工作。在某种意义上，他们可以被看作是一台计算机。
集群系统中的单个计算机通常称为节点，通常通过局域网连接，但也有其它的可能连接方式。集群计算机通常用来改进单个计算机的计算速度和/或可靠性。
一般情况下集群计算机比单个计算机，工作站或超级计算机性能价格比要高得多。

  集群就是一组相互独立的计算机，通过高速的网络组成一个计算机系统，每个集群节点都是运行其自己进程的一个独立服务器。
对网络用户来讲，网站后端就是一个单一的系统，协同起来向用户提供系统资源，系统服务。通过网络连接组合成一个组合来共同完一个任务
```
![3.2.1_常见的集群结果图](https://github.com/mutistic/mutistic.summarize/blob/master/01_%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/design/s1_architecture/s1_3.2.1_%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%9C%E5%9B%BE.png)

2、集群的特点：
```
  1、高性能(performance)： 网络服务的工作负载通常是大量相互独立的任务，通过一组服务器分而治之，可以获得很高的整体性能

  2、价格有效性（性价比）：通常一套系统集群架构，只需要几台或数十台服务器主机即可，与动则上百万的专用超级计算机相比具有更高的性价比。
组成集群系统的PC服务器或RISC服务器和标准网络设备因为大规模生产降低成本，价格低，具有最高的性能/价格比。
若整体性能随着结点数的增长而接近线性增加，该系统的性能/价格比接近于PC服务器。所以，这种松耦合结构比紧耦合的多处理器系统具有更好的性能/价格比

  3、可伸缩性：集群系统中的结点数目可以增长到几千个，乃至上万个，其伸缩性远超过单台超级计算机。
当服务器负载压力增长的时候，系统能够扩展来满足需求，且不降低服务质量

  4、高可用性：在硬件和软件上都有冗余，通过检测软硬件的故障，将故障屏蔽，由存活结点提供服务，可实现高可用性。即使部分硬件和软件发生故障，但整个系统的服务必须是7*24小时运行的。
当发现一个模块失败时，要这模块上提供的服务迁移到其他模块上。在理想状况下，这种迁移是即时的、自动的
```
3、集群的优势：
```
  1、透明性：如果一部分服务器宕机了业务不受影响，一般耦合度没有那么高，依赖关系没有那么高。比如NFS服务器宕机了其他就挂载不了了，这样依赖性太强。
如何高效地使得由多个独立计算机组成的松藕合的集群系统构成一个虚拟服务器；客户端应用程序与集群系统交互时，就像与一台高性能、高可用的服务器交互一样，
客户端无须作任何修改。部分服务器的切入和切出不会中断服务，这对用户也是透明的。

  2、高性能：访问量增加，能够轻松扩展。性能要接近线性加速，这需要设计很好的软硬件的体系结构，消除系统可能存在的瓶颈。将负载较均衡地调度到各台服务器上。

  3、可管理性：整个系统可能在物理上很大，要使集群系统变得易管理，就像管理一个单一映像系统一样。在理想状况下，软硬件模块的插入能做到即插即用（Plug & Play）。

  4、可编程性：在集群系统上，容易开发应用程序，门户网站会要求这个
```
4、集群分类：
```
  1、负载均衡集群（Load balancing clusters）简称LBC：
  负载均衡集群为企业提供了更为实用，性价比更高的系统架构解决方案。负载均衡集群把很多客户集中访问的请求负载压力尽可能平均的分摊到计算机集群中处理。
客户请求负载通常包括"应用程度处理负载"和"网络流量负载"。这样的系统非常适合向使用同一组应用程序为大量用户提供服务。
每个节点都可以承担一定的访问请求负载压力，并且可以实现访问请求在各节点之间动态分配，以实现负载均衡。
  负载均衡运行时，一般通过一个或多个前端负载均衡器将客户访问请求分发到后端一组服务器上，从而达到整个系统的高性能和高可用性。这样计算机集群有时也被称为服务器群。
一般高可用性集群和负载均衡集群会使用类似的技术，或同时具有高可用性与负载均衡的特点。
  负载均衡集群的作用：分担访问流量（负载均衡）、保持业务的连续性（高可用性）

  2、高可用性集群（High-availability clusters）简称HAC：
  一般是指当集群中的任意一个节点失效的情况下，节点上的所有任务自动转移到其他正常的节点上，并且此过程不影响整个集群的运行，不影响业务的提供。
  类似是集群中运行着两个或两个以上的一样的节点，当某个主节点出现故障的时候，那么其他作为从节点的节点就会接替主节点上面的任务。
从节点可以接管主节点的资源（IP地址，架构身份等），此时用户不会发现提供服务的对象从主节点转移到从节点。
  高可用性集群的作用：当一个机器宕机另一台进行接管。
  比较常用的高可用集群开源软件有：keepalive，heardbeat

  3、高性能计算集群（High-perfomance clusters）简称HPC：
  高性能计算集群采用将计算任务分配到集群的不同计算节点儿提高计算能力，因而主要应用在科学计算领域。比较流行的HPC采用Linux操作系统和其它一些免费软件来完成并行运算。
这一集群配置通常被称为Beowulf集群。这类集群通常运行特定的程序以发挥HPCcluster的并行能力。这类程序一般应用特定的运行库, 比如专为科学计算设计的MPI库。
  HPC集群特别适合于在计算中各计算节点之间发生大量数据通讯的计算作业，比如一个节点的中间结果会影响到其它节点计算结果的情况。
  常用开源集群软件有：lvs，keepalived，haproxy，nginx，apache，heartbeat
  常用商业集群硬件有：F5,Netscaler，Radware，A10等

  4、网格计算（Gridcomputing）：参阅：https://baike.baidu.com/item/%E7%BD%91%E6%A0%BC%E8%AE%A1%E7%AE%97
```


### <a id="a_33">3.3、几种架构对比</a> <a href="#a_32">next</a> <a href="#a_41">next</a>
1、SOA和微服务的区别：
```
  1、SOA喜欢重用，微服务喜欢重写：
  SOA的主要目的是为了企业各个系统更 加容易地融合在一起。 说到SOA不得不说ESB(EnterpriseService Bus)。 ESB是什么? 可以把ESB想象成一个连接所有企业级服务的脚手架。
通过service broker，它可以把不同数据格式或模型转成canonical格式，把XML的输入转成CSV传给legacy服务，把SOAP 1.1服务转成 SOAP 1.2等等。 它还可以把一个服务路由到另一个服务上，
也可以集中化管理业务逻辑，规则和验证等等。 它还有一个重要功能是消息队列和事件驱动的消息传递，比如把JMS服务转化成SOAP协议。 各服务间可能有复杂的依赖关系。

  微服务通常由重写一个模块开始。要把整个巨石型的应用重写是有很大的风险的，也不一定必要。我们向微服务迁移的时候通常从耦合度最低的模块或对扩展性要求最高的模块开始，
把它们一个一个剥离出来用敏捷地重写，可以尝试最新的技术和语言和框架，然 后单独布署。 它通常不依赖其他服务。微服务中常用的API Gateway的模式主要目的也不是重用代码，
而是减少客户端和服务间的往来。API gateway模式不等同与Facade模式，我们可以使用如future之类的调用，甚至返回不完整数据

  2、SOA喜欢水平服务，微服务喜欢垂直服务：
  SOA设计喜欢给服务分层(如Service Layers模式)。 我们常常见到一个Entity服务层的设计，美其名曰Data Access Layer。 这种设计要求所有的服务都通过这个Entity服务层
来获取数据。 这种设计非常不灵活，比如每次数据层的改动都可能影响到所有业务层的服务。 而每个微服务通常有它自己独立的data store。 我们在拆分数据库时可以适当的做些
去范式化(denormalization)，让它不需要依赖其他服务的数据。

  微服务通常是直接面对用户的，每个微服务通常直接为用户提供某个功能。 类似的功能可能针对手机有一个服务，针对机顶盒是另外一个服务。 在SOA设计模式中这种情况通常会用到
Multi-ChannelEndpoint的模式返回一个大而全的结果兼顾到所有的客户端的需求。

  3、SOA喜欢自上而下，微服务喜欢自下而上：
  SOA架构在设计开始时会先定义好服务合同(service contract)。 它喜欢集中管理所有的服务，包括集中管理业务逻辑，数据，流程，schema，等等。 它使用Enterprise
Inventory和Service Composition等方法来集中管理服务。 SOA架构通常会预先把每个模块服务接口都定义好。 模块系统间的通讯必须遵守这些接口，各服务是针对他们的调用者。
SOA架构适用于TOGAF之类的架构方法论。

  微服务则敏捷得多。只要用户用得到，就先把这个服务挖出来。然后针对性的，快速确认业务需求，快速开发迭代
```

2、区分：
```
  区别分布式的方式是根据不同机器不同业务，注：分布式需要做好事务管理。
  区别集群的方式是根据部署多台服务器业务是否相同，注：集群模式需要做好session共享，确保在不同服务器切换的过程中不会因为没有获取到session而中止退出服务
  微服务与分布式的细微差别是，微服务的应用不一定是分散在多个服务器上，他也可以是同一个服务器
```

---
## <a id="a_04">四、架构技术选型：</a> <a href="#a_03">三、简单理解几种架构</a> <a href="#a_04"></a>
### <a id="a_41">4.1、</a> <a href="#a_31">next</a> <a href="#a_42">next</a>
```
```

---
<a id="a_down"></a>  
<a href="#a_top">Top</a> 
<a href="#a_catalogue">Catalogue</a>